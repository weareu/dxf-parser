/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DxfParser"] = factory();
	else
		root["DxfParser"] = factory();
})(typeof self !== 'undefined' ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./esm/AutoCadColorIndex.js":
/*!**********************************!*\
  !*** ./esm/AutoCadColorIndex.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * AutoCad files sometimes use an indexed color value between 1 and 255 inclusive.\n * Each value corresponds to a color. index 1 is red, that is 16711680 or 0xFF0000.\n * index 0 and 256, while included in this array, are actually reserved for inheritance\n * values in AutoCad so they should not be used for index color lookups.\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    0,\n    16711680,\n    16776960,\n    65280,\n    65535,\n    255,\n    16711935,\n    16777215,\n    8421504,\n    12632256,\n    16711680,\n    16744319,\n    13369344,\n    13395558,\n    10027008,\n    10046540,\n    8323072,\n    8339263,\n    4980736,\n    4990502,\n    16727808,\n    16752511,\n    13382400,\n    13401958,\n    10036736,\n    10051404,\n    8331008,\n    8343359,\n    4985600,\n    4992806,\n    16744192,\n    16760703,\n    13395456,\n    13408614,\n    10046464,\n    10056268,\n    8339200,\n    8347455,\n    4990464,\n    4995366,\n    16760576,\n    16768895,\n    13408512,\n    13415014,\n    10056192,\n    10061132,\n    8347392,\n    8351551,\n    4995328,\n    4997670,\n    16776960,\n    16777087,\n    13421568,\n    13421670,\n    10000384,\n    10000460,\n    8355584,\n    8355647,\n    5000192,\n    5000230,\n    12582656,\n    14679935,\n    10079232,\n    11717734,\n    7510016,\n    8755276,\n    6258432,\n    7307071,\n    3755008,\n    4344870,\n    8388352,\n    12582783,\n    6736896,\n    10079334,\n    5019648,\n    7510092,\n    4161280,\n    6258495,\n    2509824,\n    3755046,\n    4194048,\n    10485631,\n    3394560,\n    8375398,\n    2529280,\n    6264908,\n    2064128,\n    5209919,\n    1264640,\n    3099686,\n    65280,\n    8388479,\n    52224,\n    6736998,\n    38912,\n    5019724,\n    32512,\n    4161343,\n    19456,\n    2509862,\n    65343,\n    8388511,\n    52275,\n    6737023,\n    38950,\n    5019743,\n    32543,\n    4161359,\n    19475,\n    2509871,\n    65407,\n    8388543,\n    52326,\n    6737049,\n    38988,\n    5019762,\n    32575,\n    4161375,\n    19494,\n    2509881,\n    65471,\n    8388575,\n    52377,\n    6737074,\n    39026,\n    5019781,\n    32607,\n    4161391,\n    19513,\n    2509890,\n    65535,\n    8388607,\n    52428,\n    6737100,\n    39064,\n    5019800,\n    32639,\n    4161407,\n    19532,\n    2509900,\n    49151,\n    8380415,\n    39372,\n    6730444,\n    29336,\n    5014936,\n    24447,\n    4157311,\n    14668,\n    2507340,\n    32767,\n    8372223,\n    26316,\n    6724044,\n    19608,\n    5010072,\n    16255,\n    4153215,\n    9804,\n    2505036,\n    16383,\n    8364031,\n    13260,\n    6717388,\n    9880,\n    5005208,\n    8063,\n    4149119,\n    4940,\n    2502476,\n    255,\n    8355839,\n    204,\n    6710988,\n    152,\n    5000344,\n    127,\n    4145023,\n    76,\n    2500172,\n    4129023,\n    10452991,\n    3342540,\n    8349388,\n    2490520,\n    6245528,\n    2031743,\n    5193599,\n    1245260,\n    3089996,\n    8323327,\n    12550143,\n    6684876,\n    10053324,\n    4980888,\n    7490712,\n    4128895,\n    6242175,\n    2490444,\n    3745356,\n    12517631,\n    14647295,\n    10027212,\n    11691724,\n    7471256,\n    8735896,\n    6226047,\n    7290751,\n    3735628,\n    4335180,\n    16711935,\n    16744447,\n    13369548,\n    13395660,\n    9961624,\n    9981080,\n    8323199,\n    8339327,\n    4980812,\n    4990540,\n    16711871,\n    16744415,\n    13369497,\n    13395634,\n    9961586,\n    9981061,\n    8323167,\n    8339311,\n    4980793,\n    4990530,\n    16711807,\n    16744383,\n    13369446,\n    13395609,\n    9961548,\n    9981042,\n    8323135,\n    8339295,\n    4980774,\n    4990521,\n    16711743,\n    16744351,\n    13369395,\n    13395583,\n    9961510,\n    9981023,\n    8323103,\n    8339279,\n    4980755,\n    4990511,\n    3355443,\n    5987163,\n    8684676,\n    11382189,\n    14079702,\n    16777215\n]);\n\n\n//# sourceURL=webpack://DxfParser/./esm/AutoCadColorIndex.js?");

/***/ }),

/***/ "./esm/DxfArrayScanner.js":
/*!********************************!*\
  !*** ./esm/DxfArrayScanner.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DxfArrayScanner)\n/* harmony export */ });\n/**\n * DxfArrayScanner\n *\n * Based off the AutoCad 2012 DXF Reference\n * http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf\n *\n * Reads through an array representing lines of a dxf file. Takes an array and\n * provides an easy interface to extract group code and value pairs.\n * @param data - an array where each element represents a line in the dxf file\n * @constructor\n */\nclass DxfArrayScanner {\n    _pointer = 0;\n    _eof = false;\n    lastReadGroup;\n    _data;\n    constructor(data) {\n        this._data = data;\n    }\n    /**\n     * Gets the next group (code, value) from the array. A group is two consecutive elements\n     * in the array. The first is the code, the second is the value.\n     * @returns {{code: Number}|*}\n     */\n    next() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        this._pointer++;\n        group.value = parseGroupValue(group.code, this._data[this._pointer].trim());\n        this._pointer++;\n        if (group.code === 0 && group.value === 'EOF')\n            this._eof = true;\n        this.lastReadGroup = group;\n        return group;\n    }\n    peek() {\n        if (!this.hasNext()) {\n            if (!this._eof)\n                throw new Error('Unexpected end of input: EOF group not read before end of file. Ended on code ' + this._data[this._pointer]);\n            else\n                throw new Error('Cannot call \\'next\\' after EOF group has been read');\n        }\n        const group = {\n            code: parseInt(this._data[this._pointer])\n        };\n        group.value = parseGroupValue(group.code, this._data[this._pointer + 1].trim());\n        return group;\n    }\n    rewind(numberOfGroups = 1) {\n        this._pointer = this._pointer - numberOfGroups * 2;\n    }\n    /**\n     * Returns true if there is another code/value pair (2 elements in the array).\n     * @returns {boolean}\n     */\n    hasNext() {\n        // Check if we have read EOF group code\n        if (this._eof) {\n            return false;\n        }\n        // We need to be sure there are two lines available\n        if (this._pointer > this._data.length - 2) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Returns true if the scanner is at the end of the array\n     * @returns {boolean}\n     */\n    isEOF() {\n        return this._eof;\n    }\n}\n/**\n * Parse a value to its proper type.\n * See pages 3 - 10 of the AutoCad DXF 2012 reference given at the top of this file\n *\n * @param code\n * @param value\n * @returns {*}\n */\nfunction parseGroupValue(code, value) {\n    if (code <= 9)\n        return value;\n    if (code >= 10 && code <= 59)\n        return parseFloat(value);\n    if (code >= 60 && code <= 99)\n        return parseInt(value);\n    if (code >= 100 && code <= 109)\n        return value;\n    if (code >= 110 && code <= 149)\n        return parseFloat(value);\n    if (code >= 160 && code <= 179)\n        return parseInt(value);\n    if (code >= 210 && code <= 239)\n        return parseFloat(value);\n    if (code >= 270 && code <= 289)\n        return parseInt(value);\n    if (code >= 290 && code <= 299)\n        return parseBoolean(value);\n    if (code >= 300 && code <= 369)\n        return value;\n    if (code >= 370 && code <= 389)\n        return parseInt(value);\n    if (code >= 390 && code <= 399)\n        return value;\n    if (code >= 400 && code <= 409)\n        return parseInt(value);\n    if (code >= 410 && code <= 419)\n        return value;\n    if (code >= 420 && code <= 429)\n        return parseInt(value);\n    if (code >= 430 && code <= 439)\n        return value;\n    if (code >= 440 && code <= 459)\n        return parseInt(value);\n    if (code >= 460 && code <= 469)\n        return parseFloat(value);\n    if (code >= 470 && code <= 481)\n        return value;\n    if (code === 999)\n        return value;\n    if (code >= 1000 && code <= 1009)\n        return value;\n    if (code >= 1010 && code <= 1059)\n        return parseFloat(value);\n    if (code >= 1060 && code <= 1071)\n        return parseInt(value);\n    console.log('WARNING: Group code does not have a defined type: %j', { code: code, value: value });\n    return value;\n}\n/**\n * Parse a boolean according to a 1 or 0 value\n * @param str\n * @returns {boolean}\n */\nfunction parseBoolean(str) {\n    if (str === '0')\n        return false;\n    if (str === '1')\n        return true;\n    throw TypeError('String \\'' + str + '\\' cannot be cast to Boolean type');\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/DxfArrayScanner.js?");

/***/ }),

/***/ "./esm/DxfParser.js":
/*!**************************!*\
  !*** ./esm/DxfParser.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DxfParser)\n/* harmony export */ });\n/* harmony import */ var _DxfArrayScanner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DxfArrayScanner.js */ \"./esm/DxfArrayScanner.js\");\n/* harmony import */ var _AutoCadColorIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AutoCadColorIndex.js */ \"./esm/AutoCadColorIndex.js\");\n/* harmony import */ var _entities_3dface_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entities/3dface.js */ \"./esm/entities/3dface.js\");\n/* harmony import */ var _entities_3dsolid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./entities/3dsolid.js */ \"./esm/entities/3dsolid.js\");\n/* harmony import */ var _entities_arc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entities/arc.js */ \"./esm/entities/arc.js\");\n/* harmony import */ var _entities_attdef_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entities/attdef.js */ \"./esm/entities/attdef.js\");\n/* harmony import */ var _entities_circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./entities/circle.js */ \"./esm/entities/circle.js\");\n/* harmony import */ var _entities_dimension_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entities/dimension.js */ \"./esm/entities/dimension.js\");\n/* harmony import */ var _entities_mleader_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./entities/mleader.js */ \"./esm/entities/mleader.js\");\n/* harmony import */ var _entities_ellipse_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./entities/ellipse.js */ \"./esm/entities/ellipse.js\");\n/* harmony import */ var _entities_insert_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./entities/insert.js */ \"./esm/entities/insert.js\");\n/* harmony import */ var _entities_line_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./entities/line.js */ \"./esm/entities/line.js\");\n/* harmony import */ var _entities_lwpolyline_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./entities/lwpolyline.js */ \"./esm/entities/lwpolyline.js\");\n/* harmony import */ var _entities_mtext_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./entities/mtext.js */ \"./esm/entities/mtext.js\");\n/* harmony import */ var _entities_point_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./entities/point.js */ \"./esm/entities/point.js\");\n/* harmony import */ var _entities_polyline_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./entities/polyline.js */ \"./esm/entities/polyline.js\");\n/* harmony import */ var _entities_solid_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./entities/solid.js */ \"./esm/entities/solid.js\");\n/* harmony import */ var _entities_spline_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./entities/spline.js */ \"./esm/entities/spline.js\");\n/* harmony import */ var _entities_text_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./entities/text.js */ \"./esm/entities/text.js\");\n/* harmony import */ var _entities_hatch_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./entities/hatch.js */ \"./esm/entities/hatch.js\");\n/* harmony import */ var _entities_mesh_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./entities/mesh.js */ \"./esm/entities/mesh.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//import Vertex from './entities/.js';\n\n//log.setLevel('trace');\n//log.setLevel('debug');\n//log.setLevel('info');\n//log.setLevel('warn');\nloglevel__WEBPACK_IMPORTED_MODULE_21__.setLevel('error');\nfunction registerDefaultEntityHandlers(dxfParser) {\n    // Supported entities here (some entity code is still being refactored into this flow)\n    dxfParser.registerEntityHandler(_entities_3dface_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_arc_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_attdef_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_circle_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_dimension_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_mleader_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_ellipse_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_insert_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_line_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_lwpolyline_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_mtext_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_point_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_polyline_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_solid_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_spline_js__WEBPACK_IMPORTED_MODULE_17__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_text_js__WEBPACK_IMPORTED_MODULE_18__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_hatch_js__WEBPACK_IMPORTED_MODULE_19__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_mesh_js__WEBPACK_IMPORTED_MODULE_20__[\"default\"]);\n    dxfParser.registerEntityHandler(_entities_3dsolid_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n    //dxfParser.registerEntityHandler(require('./entities/vertex'));\n}\nclass DxfParser {\n    _entityHandlers = {};\n    constructor() {\n        registerDefaultEntityHandlers(this);\n    }\n    parse(source) {\n        if (typeof source === 'string') {\n            return this._parse(source);\n        }\n        else {\n            console.error('Cannot read dxf source of type `' + typeof (source));\n            return null;\n        }\n    }\n    registerEntityHandler(handlerType) {\n        const instance = new handlerType();\n        this._entityHandlers[instance.ForEntityName] = instance;\n    }\n    parseSync(source) {\n        return this.parse(source);\n    }\n    parseStream(stream) {\n        let dxfString = \"\";\n        const self = this;\n        return new Promise((res, rej) => {\n            stream.on('data', (chunk) => {\n                dxfString += chunk;\n            });\n            stream.on('end', () => {\n                try {\n                    res(self._parse(dxfString));\n                }\n                catch (err) {\n                    rej(err);\n                }\n            });\n            stream.on('error', (err) => {\n                rej(err);\n            });\n        });\n    }\n    _parse(dxfString) {\n        const dxf = {};\n        let lastHandle = 0;\n        const dxfLinesArray = dxfString.split(/\\r\\n|\\r|\\n/g);\n        const scanner = new _DxfArrayScanner_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](dxfLinesArray);\n        if (!scanner.hasNext())\n            throw Error('Empty file');\n        const self = this;\n        let curr;\n        function parseAll() {\n            curr = scanner.next();\n            while (!scanner.isEOF()) {\n                if (curr.code === 0 && curr.value === 'SECTION') {\n                    curr = scanner.next();\n                    // Be sure we are reading a section code\n                    if (curr.code !== 2) {\n                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));\n                        curr = scanner.next();\n                        continue;\n                    }\n                    if (curr.value === 'HEADER') {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('> HEADER');\n                        dxf.header = parseHeader();\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('<');\n                    }\n                    else if (curr.value === 'BLOCKS') {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('> BLOCKS');\n                        dxf.blocks = parseBlocks();\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('<');\n                    }\n                    else if (curr.value === 'ENTITIES') {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('> ENTITIES');\n                        dxf.entities = parseEntities(false);\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('<');\n                    }\n                    else if (curr.value === 'TABLES') {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('> TABLES');\n                        dxf.tables = parseTables();\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('<');\n                    }\n                    else if (curr.value === 'EOF') {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('EOF');\n                    }\n                    else {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.warn('Skipping section \\'%s\\'', curr.value);\n                    }\n                }\n                else {\n                    curr = scanner.next();\n                }\n                // If is a new section\n            }\n        }\n        /**\n         *\n         * @return {object} header\n         */\n        function parseHeader() {\n            // interesting variables:\n            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE\n            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm\n            // Also see VPORT table entries\n            let currVarName = null;\n            let currVarValue = null;\n            const header = {};\n            // loop through header variables\n            curr = scanner.next();\n            while (true) {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    break;\n                }\n                else if (curr.code === 9) {\n                    if (currVarName)\n                        header[currVarName] = currVarValue;\n                    currVarName = curr.value;\n                    // Filter here for particular variables we are interested in\n                }\n                else {\n                    if (curr.code === 10) {\n                        currVarValue = { x: curr.value };\n                    }\n                    else if (curr.code === 20) {\n                        currVarValue.y = curr.value;\n                    }\n                    else if (curr.code === 30) {\n                        currVarValue.z = curr.value;\n                    }\n                    else {\n                        currVarValue = curr.value;\n                    }\n                }\n                curr = scanner.next();\n            }\n            // console.log(util.inspect(header, { colors: true, depth: null }));\n            curr = scanner.next(); // swallow up ENDSEC\n            return header;\n        }\n        /**\n         *\n         */\n        function parseBlocks() {\n            const blocks = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC')) {\n                    break;\n                }\n                if (groupIs(curr, 0, 'BLOCK')) {\n                    loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('block {');\n                    const block = parseBlock();\n                    loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                    ensureHandle(block);\n                    if (!block.name)\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.error('block with handle \"' + block.handle + '\" is missing a name.');\n                    else\n                        blocks[block.name] = block;\n                }\n                else {\n                    logUnhandledGroup(curr);\n                    curr = scanner.next();\n                }\n            }\n            return blocks;\n        }\n        function parseBlock() {\n            const block = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                switch (curr.code) {\n                    case 1:\n                        block.xrefPath = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 2:\n                        block.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        block.name2 = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 5:\n                        block.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 8:\n                        block.layer = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        block.position = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 67:\n                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;\n                        curr = scanner.next();\n                        break;\n                    case 70:\n                        if (curr.value != 0) {\n                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');\n                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');\n                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');\n                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');\n                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');\n                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');\n                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');\n                            block.type = curr.value;\n                        }\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        // ignore class markers\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        block.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value == 'ENDBLK')\n                            break;\n                        block.entities = parseEntities(true);\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n                if (groupIs(curr, 0, 'ENDBLK')) {\n                    curr = scanner.next();\n                    break;\n                }\n            }\n            return block;\n        }\n        /**\n         * parseTables\n         * @return {Object} Object representing tables\n         */\n        function parseTables() {\n            const tables = {};\n            curr = scanner.next();\n            while (curr.value !== 'EOF') {\n                if (groupIs(curr, 0, 'ENDSEC'))\n                    break;\n                if (groupIs(curr, 0, 'TABLE')) {\n                    curr = scanner.next();\n                    const tableDefinition = tableDefinitions[curr.value];\n                    if (tableDefinition) {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug(curr.value + ' Table {');\n                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                    }\n                    else {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('Unhandled Table ' + curr.value);\n                    }\n                }\n                else {\n                    // else ignored\n                    curr = scanner.next();\n                }\n            }\n            curr = scanner.next();\n            return tables;\n        }\n        const END_OF_TABLE_VALUE = 'ENDTAB';\n        function parseTable(group) {\n            const tableDefinition = tableDefinitions[group.value];\n            const table = {};\n            let expectedCount = 0;\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 5:\n                        table.handle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        table.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 100:\n                        if (curr.value === 'AcDbSymbolTable') {\n                            // ignore\n                            curr = scanner.next();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    case 70:\n                        expectedCount = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        if (curr.value === tableDefinition.dxfSymbolName) {\n                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();\n                        }\n                        else {\n                            logUnhandledGroup(curr);\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                }\n            }\n            const tableRecords = table[tableDefinition.tableRecordsProperty];\n            if (tableRecords) {\n                let actualCount = (() => {\n                    if (tableRecords.constructor === Array) {\n                        return tableRecords.length;\n                    }\n                    else if (typeof (tableRecords) === 'object') {\n                        return Object.keys(tableRecords).length;\n                    }\n                    return undefined;\n                })();\n                if (expectedCount !== actualCount)\n                    loglevel__WEBPACK_IMPORTED_MODULE_21__.warn('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\\'s but expected ' + expectedCount);\n            }\n            curr = scanner.next();\n            return table;\n        }\n        function parseViewPortRecords() {\n            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration\n            let viewPort = {};\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('ViewPort {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        viewPort.name = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 10:\n                        viewPort.lowerLeftCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 11:\n                        viewPort.upperRightCorner = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 12:\n                        viewPort.center = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 13:\n                        viewPort.snapBasePoint = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 14:\n                        viewPort.snapSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 15:\n                        viewPort.gridSpacing = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 16:\n                        viewPort.viewDirectionFromTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 17:\n                        viewPort.viewTarget = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 42:\n                        viewPort.lensLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 43:\n                        viewPort.frontClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 44:\n                        viewPort.backClippingPlane = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 45:\n                        viewPort.viewHeight = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 50:\n                        viewPort.snapRotationAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 51:\n                        viewPort.viewTwistAngle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 79:\n                        viewPort.orthographicType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 110:\n                        viewPort.ucsOrigin = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 111:\n                        viewPort.ucsXAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 112:\n                        viewPort.ucsYAxis = parsePoint(curr);\n                        curr = scanner.next();\n                        break;\n                    case 281:\n                        viewPort.renderMode = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 282:\n                        // 0 is one distant light, 1 is two distant lights\n                        viewPort.defaultLightingType = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 292:\n                        viewPort.defaultLightingOn = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 330:\n                        viewPort.ownerHandle = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.\n                    case 421:\n                    case 431:\n                        viewPort.ambientColor = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New ViewPort\n                        if (curr.value === 'VPORT') {\n                            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                            viewPorts.push(viewPort);\n                            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('ViewPort {');\n                            viewPort = {};\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseTable() needs the current group\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n            viewPorts.push(viewPort);\n            return viewPorts;\n        }\n        function parseLineTypes() {\n            const ltypes = {};\n            let ltype = {};\n            let length = 0;\n            let ltypeName;\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('LType {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2:\n                        ltype.name = curr.value;\n                        ltypeName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 3:\n                        ltype.description = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 73: // Number of elements for this line type (dots, dashes, spaces);\n                        length = curr.value;\n                        if (length > 0)\n                            ltype.pattern = [];\n                        curr = scanner.next();\n                        break;\n                    case 40: // total pattern length\n                        ltype.patternLength = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 49:\n                        ltype.pattern.push(curr.value);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                        if (length > 0 && length !== ltype.pattern.length)\n                            loglevel__WEBPACK_IMPORTED_MODULE_21__.warn('lengths do not match on LTYPE pattern');\n                        ltypes[ltypeName] = ltype;\n                        ltype = {};\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('LType {');\n                        curr = scanner.next();\n                        break;\n                    default:\n                        curr = scanner.next();\n                }\n            }\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n            ltypes[ltypeName] = ltype;\n            return ltypes;\n        }\n        function parseLayers() {\n            const layers = {};\n            let layer = {};\n            let layerName;\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('Layer {');\n            curr = scanner.next();\n            while (!groupIs(curr, 0, 'ENDTAB')) {\n                switch (curr.code) {\n                    case 2: // layer name\n                        layer.name = curr.value;\n                        layerName = curr.value;\n                        curr = scanner.next();\n                        break;\n                    case 62: // color, visibility\n                        layer.visible = curr.value >= 0;\n                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.\n                        layer.colorIndex = Math.abs(curr.value);\n                        layer.color = getAcadColor(layer.colorIndex);\n                        curr = scanner.next();\n                        break;\n                    case 70: // frozen layer\n                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);\n                        curr = scanner.next();\n                        break;\n                    case 420: // TrueColor\n                        layer.color = Math.abs(curr.value);\n                        curr = scanner.next();\n                        break;\n                    case 0:\n                        // New Layer\n                        if (curr.value === 'LAYER') {\n                            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                            layers[layerName] = layer;\n                            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('Layer {');\n                            layer = {};\n                            layerName = undefined;\n                            curr = scanner.next();\n                        }\n                        break;\n                    default:\n                        logUnhandledGroup(curr);\n                        curr = scanner.next();\n                        break;\n                }\n            }\n            // Note: do not call scanner.next() here,\n            //  parseLayerTable() needs the current group\n            loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n            layers[layerName] = layer;\n            return layers;\n        }\n        const tableDefinitions = {\n            VPORT: {\n                tableRecordsProperty: 'viewPorts',\n                tableName: 'viewPort',\n                dxfSymbolName: 'VPORT',\n                parseTableRecords: parseViewPortRecords\n            },\n            LTYPE: {\n                tableRecordsProperty: 'lineTypes',\n                tableName: 'lineType',\n                dxfSymbolName: 'LTYPE',\n                parseTableRecords: parseLineTypes\n            },\n            LAYER: {\n                tableRecordsProperty: 'layers',\n                tableName: 'layer',\n                dxfSymbolName: 'LAYER',\n                parseTableRecords: parseLayers\n            }\n        };\n        /**\n         * Is called after the parser first reads the 0:ENTITIES group. The scanner\n         * should be on the start of the first entity already.\n         * @return {Array} the resulting entities\n         */\n        function parseEntities(forBlock) {\n            const entities = [];\n            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';\n            if (!forBlock) {\n                curr = scanner.next();\n            }\n            while (true) {\n                if (curr.code === 0) {\n                    if (curr.value === endingOnValue) {\n                        break;\n                    }\n                    const handler = self._entityHandlers[curr.value];\n                    if (handler != null) {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug(curr.value + ' {');\n                        const entity = handler.parseEntity(scanner, curr);\n                        curr = scanner.lastReadGroup;\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('}');\n                        ensureHandle(entity);\n                        entities.push(entity);\n                    }\n                    else {\n                        loglevel__WEBPACK_IMPORTED_MODULE_21__.warn('Unhandled entity ' + curr.value);\n                        curr = scanner.next();\n                        continue;\n                    }\n                }\n                else {\n                    // ignored lines from unsupported entity\n                    curr = scanner.next();\n                }\n            }\n            if (endingOnValue == 'ENDSEC')\n                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK\n            return entities;\n        }\n        /**\n         * Parses a 2D or 3D point, returning it as an object with x, y, and\n         * (sometimes) z property if it is 3D. It is assumed the current group\n         * is x of the point being read in, and scanner.next() will return the\n         * y. The parser will determine if there is a z point automatically.\n         * @return {Object} The 2D or 3D point as an object with x, y[, z]\n         */\n        function parsePoint(curr) {\n            const point = {};\n            let code = curr.code;\n            point.x = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code)\n                throw new Error('Expected code for point value to be ' + code +\n                    ' but got ' + curr.code + '.');\n            point.y = curr.value;\n            code += 10;\n            curr = scanner.next();\n            if (curr.code != code) {\n                scanner.rewind();\n                return point;\n            }\n            point.z = curr.value;\n            return point;\n        }\n        function ensureHandle(entity) {\n            if (!entity)\n                throw new TypeError('entity cannot be undefined or null');\n            if (!entity.handle)\n                entity.handle = lastHandle++;\n        }\n        parseAll();\n        return dxf;\n    }\n}\nfunction groupIs(group, code, value) {\n    return group.code === code && group.value === value;\n}\nfunction logUnhandledGroup(curr) {\n    loglevel__WEBPACK_IMPORTED_MODULE_21__.debug('unhandled group ' + debugCode(curr));\n}\nfunction debugCode(curr) {\n    return curr.code + ':' + curr.value;\n}\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n    return _AutoCadColorIndex_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][index];\n}\n// const BLOCK_ANONYMOUS_FLAG = 1;\n// const BLOCK_NON_CONSTANT_FLAG = 2;\n// const BLOCK_XREF_FLAG = 4;\n// const BLOCK_XREF_OVERLAY_FLAG = 8;\n// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;\n// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;\n// const BLOCK_REFERENCED_XREF = 64;\n/* Notes */\n// Code 6 of an entity indicates inheritance of properties (eg. color).\n//   BYBLOCK means inherits from block\n//   BYLAYER (default) mean inherits from layer\n\n\n//# sourceURL=webpack://DxfParser/./esm/DxfParser.js?");

/***/ }),

/***/ "./esm/ParseHelpers.js":
/*!*****************************!*\
  !*** ./esm/ParseHelpers.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkCommonEntityProperties: () => (/* binding */ checkCommonEntityProperties),\n/* harmony export */   getAcadColor: () => (/* binding */ getAcadColor),\n/* harmony export */   parseMatrix: () => (/* binding */ parseMatrix),\n/* harmony export */   parsePoint: () => (/* binding */ parsePoint)\n/* harmony export */ });\n/* harmony import */ var _AutoCadColorIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoCadColorIndex.js */ \"./esm/AutoCadColorIndex.js\");\n\n/**\n * Returns the truecolor value of the given AutoCad color index value\n * @return {Number} truecolor value as a number\n */\nfunction getAcadColor(index) {\n    return _AutoCadColorIndex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][index];\n}\n/**\n * Parses the 2D or 3D coordinate, vector, or point. When complete,\n * the scanner remains on the last group of the coordinate.\n * @param {*} scanner\n */\nfunction parsePoint(scanner) {\n    const point = {};\n    // Reread group for the first coordinate\n    scanner.rewind();\n    let curr = scanner.next();\n    let code = curr.code;\n    point.x = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code)\n        throw new Error('Expected code for point value to be ' + code +\n            ' but got ' + curr.code + '.');\n    point.y = curr.value;\n    code += 10;\n    curr = scanner.next();\n    if (curr.code != code) {\n        // Only the x and y are specified. Don't read z.\n        scanner.rewind(); // Let the calling code advance off the point\n        return point;\n    }\n    point.z = curr.value;\n    return point;\n}\n/**\n * Parses 16 numbers as an array. When complete,\n * the scanner remains on the last group of the value.\n * @param {*} scanner\n * @param {*} groupCode\n */\nfunction parseMatrix(scanner, groupCode) {\n    // Reread group for the first coordinate\n    scanner.rewind();\n    const matrix = [];\n    for (let i = 0; i < 16; i++) {\n        const curr = scanner.next();\n        if (curr.code !== groupCode) {\n            throw new Error('Expected code for matrix value to be ' + groupCode +\n                ' but got ' + curr.code + '.');\n        }\n        matrix.push(curr.value);\n    }\n    return matrix;\n}\n/**\n * Attempts to parse codes common to all entities. Returns true if the group\n * was handled by this function.\n * @param {*} entity - the entity currently being parsed\n * @param {*} curr - the current group being parsed\n */\nfunction checkCommonEntityProperties(entity, curr, scanner) {\n    switch (curr.code) {\n        case 0:\n            entity.type = curr.value;\n            break;\n        case 5:\n            entity.handle = curr.value;\n            break;\n        case 6:\n            entity.lineType = curr.value;\n            break;\n        case 8: // Layer name\n            entity.layer = curr.value;\n            break;\n        case 48:\n            entity.lineTypeScale = curr.value;\n            break;\n        case 60:\n            entity.visible = curr.value === 0;\n            break;\n        case 62: // Acad Index Color. 0 inherits ByBlock. 256 inherits ByLayer. Default is bylayer\n            entity.colorIndex = curr.value;\n            entity.color = getAcadColor(Math.abs(curr.value));\n            break;\n        case 67:\n            entity.inPaperSpace = curr.value !== 0;\n            break;\n        case 100:\n            //ignore\n            break;\n        case 101: // Embedded Object in ACAD 2018.\n            // See https://ezdxf.readthedocs.io/en/master/dxfinternals/dxftags.html#embedded-objects\n            while (curr.code != 0) {\n                curr = scanner.next();\n            }\n            scanner.rewind();\n            break;\n        case 330:\n            entity.ownerHandle = curr.value;\n            break;\n        case 347:\n            entity.materialObjectHandle = curr.value;\n            break;\n        case 370:\n            //From https://www.woutware.com/Forum/Topic/955/lineweight?returnUrl=%2FForum%2FUserPosts%3FuserId%3D478262319\n            // An integer representing 100th of mm, must be one of the following values:\n            // 0, 5, 9, 13, 15, 18, 20, 25, 30, 35, 40, 50, 53, 60, 70, 80, 90, 100, 106, 120, 140, 158, 200, 211.\n            // -3 = STANDARD, -2 = BYLAYER, -1 = BYBLOCK\n            entity.lineweight = curr.value;\n            break;\n        case 420: // TrueColor Color\n            entity.color = curr.value;\n            break;\n        case 1000:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.customStrings = entity.extendedData.customStrings || [];\n            entity.extendedData.customStrings.push(curr.value);\n            break;\n        case 1001:\n            entity.extendedData = entity.extendedData || {};\n            entity.extendedData.applicationName = curr.value;\n            break;\n        default:\n            return false;\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/ParseHelpers.js?");

/***/ }),

/***/ "./esm/entities/3dface.js":
/*!********************************!*\
  !*** ./esm/entities/3dface.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThreeDface)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass ThreeDface {\n    ForEntityName = '3DFACE';\n    parseEntity(scanner, curr) {\n        const entity = {\n            type: curr.value,\n            vertices: [],\n            shape: false,\n            hasContinuousLinetypePattern: false,\n            layer: '',\n            colorIndex: 0,\n            lineType: '',\n            lineTypeScale: 1,\n            visible: true,\n            handle: 0,\n            color: 0,\n            inPaperSpace: false,\n            ownerHandle: '',\n            materialObjectHandle: 0,\n            lineweight: -3,\n            extendedData: { customStrings: [], applicationName: '' },\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = (curr.value & 1) === 1;\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) === 128;\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parse3dFaceVertices(scanner, curr);\n                    curr = scanner.lastReadGroup;\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parse3dFaceVertices(scanner, curr) {\n    const vertices = [];\n    const verticesPer3dFace = 4; // Up to four vertices per face, 3 for TIN\n    let vertexIsStarted = false;\n    let vertexIsFinished = false;\n    for (let i = 0; i < verticesPer3dFace; i++) { // Changed <= to <\n        const vertex = { x: 0, y: 0, z: 0 };\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X0\n                case 11: // X1\n                case 12: // X2\n                case 13: // X3\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                case 21:\n                case 22:\n                case 23:\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                case 31:\n                case 32:\n                case 33:\n                    vertex.z = curr.value;\n                    break;\n                default:\n                    if (vertexIsStarted) {\n                        vertices.push(vertex); // Push vertex before returning\n                    }\n                    scanner.rewind();\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        if (vertexIsStarted) {\n            vertices.push(vertex); // Push completed vertex\n        }\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/3dface.js?");

/***/ }),

/***/ "./esm/entities/3dsolid.js":
/*!*********************************!*\
  !*** ./esm/entities/3dsolid.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Solid3d)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Solid3d {\n    ForEntityName = '3DSOLID';\n    parseEntity(scanner, curr) {\n        const entity = {\n            type: curr.value,\n            modelerFormatVersion: 0,\n            hasSolidHistory: false,\n            proprietaryData: [],\n            additionalProprietaryData: [],\n            historyObjectHandle: '',\n            acisData: '',\n            acisHeader: null,\n            body: null,\n            layer: '',\n            colorIndex: 0,\n            lineType: '',\n            lineTypeScale: 1,\n            visible: true,\n            handle: 0,\n            color: 0,\n            inPaperSpace: false,\n            ownerHandle: '',\n            materialObjectHandle: 0,\n            lineweight: -3,\n            extendedData: { customStrings: [], applicationName: '' },\n            parseError: undefined,\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF() && curr.code !== 0) {\n            switch (curr.code) {\n                case 5:\n                    entity.handle = parseInt(curr.value, 16);\n                    break;\n                case 70:\n                    entity.modelerFormatVersion = curr.value;\n                    break;\n                case 1:\n                    entity.proprietaryData.push(curr.value);\n                    break;\n                case 3:\n                    entity.additionalProprietaryData.push(curr.value);\n                    break;\n                case 290:\n                    entity.hasSolidHistory = !!curr.value;\n                    break;\n                case 350:\n                    entity.historyObjectHandle = curr.value;\n                    break;\n                case 100:\n                    break;\n                case 1001:\n                    entity.extendedData.applicationName = curr.value;\n                    curr = scanner.next();\n                    while (curr.code === 1000 || curr.code === 1070 || curr.code === 1071) {\n                        entity.extendedData.customStrings.push(curr.value);\n                        curr = scanner.next();\n                    }\n                    scanner.rewind();\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        // Decode ACIS data\n        const rawData = [...entity.proprietaryData, ...entity.additionalProprietaryData].join('');\n        let decoded = '';\n        try {\n            for (const char of rawData) {\n                const code = char.charCodeAt(0);\n                decoded += String.fromCharCode(159 - code);\n            }\n            decoded = decoded.replace(/\\x7F/g, '');\n            decoded = decoded.replace(/\\s+/g, ' ').trim();\n            entity.acisData = decoded;\n        }\n        catch (error) {\n            entity.parseError = `Failed to decode ACIS data: ${error.message}`;\n            return entity;\n        }\n        // Parse ACIS data with streaming\n        try {\n            this.parseAcisDataStreaming(entity);\n        }\n        catch (error) {\n            entity.parseError = `Failed to parse ACIS data: ${error.message}`;\n            entity.acisHeader = null;\n            entity.body = null;\n        }\n        return entity;\n    }\n    parseAcisDataStreaming(entity) {\n        const sat = entity.acisData.trim();\n        if (!sat) {\n            entity.parseError = 'Empty ACIS data';\n            return;\n        }\n        // Split into lines (entities separated by #)\n        const lines = sat.split('#').map(l => l.trim()).filter(l => l);\n        if (lines.length === 0) {\n            entity.parseError = 'No valid ACIS data lines';\n            return;\n        }\n        // Parse header from first line\n        try {\n            const headerTokenGen = this.tokenizeLine(lines[0]);\n            entity.acisHeader = this.parseHeader([...headerTokenGen]);\n        }\n        catch (error) {\n            entity.parseError = `Failed to parse ACIS header: ${error.message}`;\n            return;\n        }\n        // Process each subsequent line as an entity\n        const entityMap = new Map();\n        let index = 0;\n        for (let i = 1; i < lines.length; i++) {\n            try {\n                const tokenGen = this.tokenizeLine(lines[i]);\n                const tokens = [...tokenGen];\n                if (tokens.length === 0)\n                    continue;\n                const type = tokens[0];\n                const attributes = tokens.slice(1);\n                entityMap.set(index, { type, attributes, resolved: null });\n                index++;\n            }\n            catch (error) {\n                console.warn(`Failed to parse entity at index ${i}: ${error.message}`);\n                continue;\n            }\n        }\n        // Find body and resolve hierarchy\n        const bodyIndex = [...entityMap.entries()].find(([_, e]) => e.type === 'body')?.[0];\n        if (bodyIndex === undefined) {\n            entity.parseError = 'No body entity found in ACIS data';\n            return;\n        }\n        try {\n            entity.body = this.resolveBody(bodyIndex, entityMap, 0);\n        }\n        catch (error) {\n            entity.parseError = `Failed to resolve body hierarchy: ${error.message}`;\n            entity.body = null;\n        }\n    }\n    *tokenizeLine(line) {\n        let i = 0;\n        while (i < line.length) {\n            if (line[i].trim() === '') {\n                i++;\n                continue;\n            }\n            if (line[i] === '$') {\n                let j = i + 1;\n                let sign = 1;\n                if (j < line.length && line[j] === '-') {\n                    sign = -1;\n                    j++;\n                }\n                let num = 0;\n                while (j < line.length && line[j].match(/\\d/)) {\n                    num = num * 10 + parseInt(line[j]);\n                    j++;\n                }\n                yield sign * num;\n                i = j;\n            }\n            else if (line[i] === '@') {\n                let j = i + 1;\n                let len = 0;\n                while (j < line.length && line[j].match(/\\d/)) {\n                    len = len * 10 + parseInt(line[j]);\n                    j++;\n                }\n                i = j;\n                // Skip leading spaces after @len\n                while (i < line.length && line[i] === ' ')\n                    i++;\n                const str = i + len <= line.length ? line.substring(i, i + len) : '';\n                if (str)\n                    yield str;\n                i += len;\n            }\n            else if (line[i] === '{') {\n                yield '{';\n                i++;\n            }\n            else if (line[i] === '}') {\n                yield '}';\n                i++;\n            }\n            else if (line[i].match(/[\\d.-]/)) {\n                let j = i;\n                while (j < line.length && line[j].match(/[\\d.eE+-]/))\n                    j++;\n                const numStr = line.substring(i, j);\n                yield numStr.includes('.') || numStr.toLowerCase().includes('e') ? parseFloat(numStr) : parseInt(numStr);\n                i = j;\n            }\n            else {\n                let j = i;\n                while (j < line.length && !line[j].match(/\\s|\\$|@|\\{|\\}/))\n                    j++;\n                const word = line.substring(i, j).trim();\n                if (word)\n                    yield word;\n                i = j;\n            }\n        }\n    }\n    parseHeader(tokens) {\n        let idx = 0;\n        const header = {\n            version: idx < tokens.length ? parseFloat(tokens[idx++]) : 0,\n            numRecords: idx < tokens.length ? parseInt(tokens[idx++]) : 0,\n            numEntities: idx < tokens.length ? parseInt(tokens[idx++]) : 0,\n            flags: idx < tokens.length ? parseInt(tokens[idx++]) : 0,\n            productId: idx < tokens.length ? tokens[idx++].toString() : '',\n            acisVersion: idx < tokens.length ? tokens[idx++].toString() : '',\n            date: idx < tokens.length ? tokens[idx++].toString() : '',\n            units: idx < tokens.length ? parseFloat(tokens[idx++]) : 0,\n            resabs: idx < tokens.length ? parseFloat(tokens[idx++]) : 0,\n            resnor: idx < tokens.length ? parseFloat(tokens[idx++]) : 0,\n        };\n        return header;\n    }\n    resolveBody(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveBody');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Body index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'body') {\n            console.warn(`Entity at index ${index} is not a body: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 2) {\n            console.warn(`Invalid attributes for body at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        let lumpPtr = -1;\n        for (let i = 1; i < attrs.length; i++) {\n            if (attrs[i] >= 0 && attrs[i] < entityMap.size) {\n                const lumpEntry = entityMap.get(attrs[i]);\n                if (lumpEntry && lumpEntry.type === 'lump') {\n                    lumpPtr = attrs[i];\n                    break;\n                }\n            }\n        }\n        const body = { lumps: [] };\n        let currentLumpPtr = lumpPtr;\n        while (currentLumpPtr >= 0 && currentLumpPtr < entityMap.size) {\n            const lumpEntry = entityMap.get(currentLumpPtr);\n            if (!lumpEntry || lumpEntry.type !== 'lump') {\n                console.warn(`Invalid lump at index ${currentLumpPtr}: ${lumpEntry?.type || 'not found'}`);\n                currentLumpPtr = lumpEntry?.attributes[2] || -1;\n                continue;\n            }\n            const lump = this.resolveLump(currentLumpPtr, entityMap, depth + 1);\n            if (lump) {\n                body.lumps.push(lump);\n            }\n            else {\n                console.warn(`Failed to resolve lump at index ${currentLumpPtr}`);\n            }\n            currentLumpPtr = lumpEntry.attributes[2] || -1;\n        }\n        if (body.lumps.length === 0) {\n            console.warn(`No lumps resolved for body ${index}`);\n        }\n        entry.resolved = body;\n        return body;\n    }\n    resolveLump(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveLump');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Lump index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'lump') {\n            console.warn(`Entity at index ${index} is not a lump: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 2) {\n            console.warn(`Invalid attributes for lump at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        let shellPtr = -1;\n        for (let i = 3; i < attrs.length; i++) {\n            if (attrs[i] >= 0 && attrs[i] < entityMap.size) {\n                const shellEntry = entityMap.get(attrs[i]);\n                if (shellEntry && shellEntry.type === 'shell') {\n                    shellPtr = attrs[i];\n                    break;\n                }\n            }\n        }\n        const lump = { shells: [] };\n        let currentShellPtr = shellPtr;\n        while (currentShellPtr >= 0 && currentShellPtr < entityMap.size) {\n            const shellEntry = entityMap.get(currentShellPtr);\n            if (!shellEntry || shellEntry.type !== 'shell') {\n                console.warn(`Invalid shell at index ${currentShellPtr}: ${shellEntry?.type || 'not found'}`);\n                currentShellPtr = shellEntry?.attributes[2] || -1;\n                continue;\n            }\n            const shell = this.resolveShell(currentShellPtr, entityMap, depth + 1);\n            if (shell) {\n                lump.shells.push(shell);\n            }\n            else {\n                console.warn(`Failed to resolve shell at index ${currentShellPtr}`);\n            }\n            currentShellPtr = shellEntry.attributes[2] || -1;\n        }\n        if (lump.shells.length === 0) {\n            console.warn(`No shells resolved for lump ${index}`);\n        }\n        entry.resolved = lump;\n        return lump;\n    }\n    resolveShell(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveShell');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Shell index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'shell') {\n            console.warn(`Entity at index ${index} is not a shell: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 2) {\n            console.warn(`Invalid attributes for shell at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        let facePtr = -1;\n        for (let i = 4; i < attrs.length; i++) {\n            if (attrs[i] >= 0 && attrs[i] < entityMap.size) {\n                const faceEntry = entityMap.get(attrs[i]);\n                if (faceEntry && faceEntry.type === 'face') {\n                    facePtr = attrs[i];\n                    break;\n                }\n            }\n        }\n        const shell = { faces: [] };\n        let currentFacePtr = facePtr;\n        while (currentFacePtr >= 0 && currentFacePtr < entityMap.size) {\n            const faceEntry = entityMap.get(currentFacePtr);\n            if (!faceEntry || faceEntry.type !== 'face') {\n                console.warn(`Invalid face at index ${currentFacePtr}: ${faceEntry?.type || 'not found'}`);\n                currentFacePtr = faceEntry?.attributes[2] || -1;\n                continue;\n            }\n            const face = this.resolveFace(currentFacePtr, entityMap, depth + 1);\n            if (face) {\n                shell.faces.push(face);\n            }\n            else {\n                console.warn(`Failed to resolve face at index ${currentFacePtr}`);\n            }\n            currentFacePtr = faceEntry.attributes[2] || -1;\n        }\n        if (shell.faces.length === 0) {\n            console.warn(`No faces resolved for shell ${index}`);\n        }\n        entry.resolved = shell;\n        return shell;\n    }\n    resolveFace(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveFace');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Face index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'face') {\n            console.warn(`Entity at index ${index} is not a face: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 6) {\n            console.warn(`Invalid attributes for face at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const loopPtr = attrs[3] >= 0 ? attrs[3] : -1;\n        const surfacePtr = attrs[6] >= 0 ? attrs[6] : attrs[4] >= 0 ? attrs[4] : -1;\n        const sense = attrs.some((attr) => attr === 'forward');\n        const doubleSided = attrs.some((attr) => attr === 'double');\n        const face = {\n            loops: [],\n            surface: surfacePtr >= 0 ? this.resolveSurface(surfacePtr, entityMap, depth + 1) : null,\n            sense,\n            doubleSided,\n        };\n        let currentLoopPtr = loopPtr;\n        while (currentLoopPtr >= 0 && currentLoopPtr < entityMap.size) {\n            const loopEntry = entityMap.get(currentLoopPtr);\n            if (!loopEntry || loopEntry.type !== 'loop') {\n                console.warn(`Invalid loop at index ${currentLoopPtr}: ${loopEntry?.type || 'not found'}`);\n                currentLoopPtr = loopEntry?.attributes[2] || -1;\n                continue;\n            }\n            const loop = this.resolveLoop(currentLoopPtr, entityMap, depth + 1);\n            if (loop) {\n                face.loops.push(loop);\n            }\n            else {\n                console.warn(`Failed to resolve loop at index ${currentLoopPtr}`);\n            }\n            currentLoopPtr = loopEntry.attributes[2] || -1;\n        }\n        if (face.loops.length === 0) {\n            console.warn(`No loops resolved for face ${index}`);\n        }\n        entry.resolved = face;\n        return face;\n    }\n    resolveLoop(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveLoop');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Loop index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'loop') {\n            console.warn(`Entity at index ${index} is not a loop: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 2) {\n            console.warn(`Invalid attributes for loop at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const coedgePtr = attrs[3] >= 0 ? attrs[3] : -1;\n        const loop = { coedges: [] };\n        let currentCoedgePtr = coedgePtr;\n        while (currentCoedgePtr >= 0 && currentCoedgePtr < entityMap.size) {\n            const coedgeEntry = entityMap.get(currentCoedgePtr);\n            if (!coedgeEntry || coedgeEntry.type !== 'coedge') {\n                console.warn(`Invalid coedge at index ${currentCoedgePtr}: ${coedgeEntry?.type || 'not found'}`);\n                currentCoedgePtr = coedgeEntry?.attributes[2] || -1;\n                continue;\n            }\n            const coedge = this.resolveCoedge(currentCoedgePtr, entityMap, depth + 1);\n            if (coedge) {\n                loop.coedges.push(coedge);\n            }\n            else {\n                console.warn(`Failed to resolve coedge at index ${currentCoedgePtr}`);\n            }\n            currentCoedgePtr = coedgeEntry.attributes[2] || -1;\n        }\n        if (loop.coedges.length === 0) {\n            console.warn(`No coedges resolved for loop ${index}`);\n        }\n        entry.resolved = loop;\n        return loop;\n    }\n    resolveCoedge(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveCoedge');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Coedge index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'coedge') {\n            console.warn(`Entity at index ${index} is not a coedge: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 6) {\n            console.warn(`Invalid attributes for coedge at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const edgePtr = attrs[5] >= 0 ? attrs[5] : -1;\n        const sense = attrs.some((attr) => attr === 'forward');\n        const partnerPtr = attrs[4] >= 0 ? attrs[4] : -1;\n        const nextPtr = attrs[2] >= 0 ? attrs[2] : -1;\n        const prevPtr = attrs[3] >= 0 ? attrs[3] : -1;\n        const coedge = {\n            edge: edgePtr >= 0 ? this.resolveEdge(edgePtr, entityMap, depth + 1) : null,\n            sense,\n            partner: partnerPtr >= 0 ? this.resolveCoedge(partnerPtr, entityMap, depth + 1) : null,\n            next: nextPtr >= 0 ? this.resolveCoedge(nextPtr, entityMap, depth + 1) : null,\n            prev: prevPtr >= 0 ? this.resolveCoedge(prevPtr, entityMap, depth + 1) : null,\n        };\n        entry.resolved = coedge;\n        return coedge;\n    }\n    resolveEdge(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveEdge');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Edge index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'edge') {\n            console.warn(`Entity at index ${index} is not an edge: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 6) {\n            console.warn(`Invalid attributes for edge at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const startVertexPtr = attrs[2] >= 0 ? attrs[2] : -1;\n        const endVertexPtr = attrs[3] >= 0 ? attrs[3] : -1;\n        const curvePtr = attrs[5] >= 0 ? attrs[5] : -1;\n        const sense = attrs.some((attr) => attr === 'forward');\n        const startParam = attrs.find((attr) => typeof attr === 'number' && attr > 0); // Approximate\n        const endParam = attrs.find((attr) => typeof attr === 'number' && attr > 0 && attr !== startParam); // Approximate\n        const edge = {\n            startVertex: startVertexPtr >= 0 ? this.resolveVertex(startVertexPtr, entityMap, depth + 1) : null,\n            endVertex: endVertexPtr >= 0 ? this.resolveVertex(endVertexPtr, entityMap, depth + 1) : null,\n            curve: curvePtr >= 0 ? this.resolveCurve(curvePtr, entityMap, depth + 1) : null,\n            sense,\n            startParam,\n            endParam,\n        };\n        entry.resolved = edge;\n        return edge;\n    }\n    resolveVertex(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveVertex');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Vertex index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'vertex') {\n            console.warn(`Entity at index ${index} is not a vertex: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 3) {\n            console.warn(`Invalid attributes for vertex at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const pointPtr = attrs[2] >= 0 ? attrs[2] : -1;\n        const vertex = {\n            point: pointPtr >= 0 ? this.resolvePoint(pointPtr, entityMap, depth + 1) : null,\n        };\n        entry.resolved = vertex;\n        return vertex;\n    }\n    resolvePoint(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolvePoint');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Point index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'point') {\n            console.warn(`Entity at index ${index} is not a point: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 4) {\n            console.warn(`Invalid attributes for point at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const point = {\n            location: [attrs[1], attrs[2], attrs[3]],\n        };\n        entry.resolved = point;\n        return point;\n    }\n    resolveCurve(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveCurve');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Curve index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'straight-curve') {\n            console.warn(`Entity at index ${index} is not a straight-curve: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 7) {\n            console.warn(`Invalid attributes for curve at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const curve = {\n            origin: [attrs[1], attrs[2], attrs[3]],\n            direction: [attrs[4], attrs[5], attrs[6]],\n        };\n        entry.resolved = curve;\n        return curve;\n    }\n    resolveSurface(index, entityMap, depth) {\n        if (depth > 100) {\n            console.warn('Max recursion depth exceeded in resolveSurface');\n            return null;\n        }\n        const entry = entityMap.get(index);\n        if (!entry) {\n            console.warn(`Surface index ${index} not found in entityMap`);\n            return null;\n        }\n        if (entry.resolved)\n            return entry.resolved;\n        if (entry.type !== 'plane-surface') {\n            console.warn(`Entity at index ${index} is not a plane-surface: ${entry.type}`);\n            return null;\n        }\n        const attrs = entry.attributes;\n        if (!attrs || attrs.length < 17) {\n            console.warn(`Invalid attributes for surface at index ${index}: ${JSON.stringify(attrs)}`);\n            return null;\n        }\n        const surface = {\n            origin: [attrs[1], attrs[2], attrs[3]],\n            normal: [attrs[4], attrs[5], attrs[6]],\n            uDir: [attrs[7], attrs[8], attrs[9]],\n            vDir: [attrs[10], attrs[11], attrs[12]],\n            reverseV: attrs[13] === 'reverse_v' || attrs[13] === 'forward_v',\n            uClosed: attrs[14] === 'I',\n            vClosed: attrs[15] === 'I',\n            selfIntersect: attrs[16] === 'I',\n        };\n        entry.resolved = surface;\n        return surface;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/3dsolid.js?");

/***/ }),

/***/ "./esm/entities/arc.js":
/*!*****************************!*\
  !*** ./esm/entities/arc.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Arc)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Arc {\n    ForEntityName = 'ARC';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    entity.endAngle = Math.PI / 180 * curr.value;\n                    entity.angleLength = entity.endAngle - entity.startAngle; // angleLength is deprecated\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default: // ignored attribute\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/arc.js?");

/***/ }),

/***/ "./esm/entities/attdef.js":
/*!********************************!*\
  !*** ./esm/entities/attdef.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Attdef)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Attdef {\n    ForEntityName = 'ATTDEF';\n    parseEntity(scanner, curr) {\n        var entity = {\n            type: curr.value,\n            scale: 1,\n            textStyle: 'STANDARD'\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0) {\n                break;\n            }\n            switch (curr.code) {\n                case 1:\n                    entity.text = curr.value;\n                    break;\n                case 2:\n                    entity.tag = curr.value;\n                    break;\n                case 3:\n                    entity.prompt = curr.value;\n                    break;\n                case 7:\n                    entity.textStyle = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 40:\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.scale = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 51:\n                    entity.obliqueAngle = curr.value;\n                    break;\n                case 70:\n                    entity.invisible = !!(curr.value & 0x01);\n                    entity.constant = !!(curr.value & 0x02);\n                    entity.verificationRequired = !!(curr.value & 0x04);\n                    entity.preset = !!(curr.value & 0x08);\n                    break;\n                case 71:\n                    entity.backwards = !!(curr.value & 0x02);\n                    entity.mirrored = !!(curr.value & 0x04);\n                    break;\n                case 72:\n                    // TODO: enum values?\n                    entity.horizontalJustification = curr.value;\n                    break;\n                case 73:\n                    entity.fieldLength = curr.value;\n                    break;\n                case 74:\n                    // TODO: enum values?\n                    entity.verticalJustification = curr.value;\n                    break;\n                case 100:\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/attdef.js?");

/***/ }),

/***/ "./esm/entities/circle.js":
/*!********************************!*\
  !*** ./esm/entities/circle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Circle {\n    ForEntityName = 'CIRCLE';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.center = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40: // radius\n                    entity.radius = curr.value;\n                    break;\n                case 50: // start angle\n                    entity.startAngle = Math.PI / 180 * curr.value;\n                    break;\n                case 51: // end angle\n                    const endAngle = Math.PI / 180 * curr.value;\n                    if (endAngle < entity.startAngle)\n                        entity.angleLength = endAngle + 2 * Math.PI - entity.startAngle;\n                    else\n                        entity.angleLength = endAngle - entity.startAngle;\n                    entity.endAngle = endAngle;\n                    break;\n                default: // ignored attribute\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/circle.js?");

/***/ }),

/***/ "./esm/entities/dimension.js":
/*!***********************************!*\
  !*** ./esm/entities/dimension.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dimension)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Dimension {\n    ForEntityName = 'DIMENSION';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2: // Referenced block name\n                    entity.block = curr.value;\n                    break;\n                case 10: // X coordinate of 'first alignment point'\n                    entity.anchorPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.middleOfText = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 12: // Insertion point for clones of a dimension\n                    entity.insertionPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 13: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint1 = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 14: // Definition point for linear and angular dimensions \n                    entity.linearOrAngularPoint2 = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 15: // Definition point for diameter, radius, and angular dimensions\n                    entity.diameterOrRadiusPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 16: // Point defining dimension arc for angular dimensions\n                    entity.arcPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 70: // Dimension type\n                    entity.dimensionType = curr.value;\n                    break;\n                case 71: // 5 = Middle center\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 42: // Actual measurement\n                    entity.actualMeasurement = curr.value;\n                    break;\n                case 1: // Text entered by user explicitly\n                    entity.text = curr.value;\n                    break;\n                case 50: // Angle of rotated, horizontal, or vertical dimensions\n                    entity.angle = curr.value;\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/dimension.js?");

/***/ }),

/***/ "./esm/entities/ellipse.js":
/*!*********************************!*\
  !*** ./esm/entities/ellipse.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Ellipse {\n    ForEntityName = 'ELLIPSE';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.center = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.majorAxisEndPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40:\n                    entity.axisRatio = curr.value;\n                    break;\n                case 41:\n                    entity.startAngle = curr.value;\n                    break;\n                case 42:\n                    entity.endAngle = curr.value;\n                    break;\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/ellipse.js?");

/***/ }),

/***/ "./esm/entities/hatch.js":
/*!*******************************!*\
  !*** ./esm/entities/hatch.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Hatch)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Hatch {\n    ForEntityName = 'HATCH';\n    parseEntity(scanner, curr) {\n        const entity = {\n            type: curr.value,\n            boundaries: [],\n            solidFill: false,\n            associativity: false,\n            boundaryPathsCount: 0,\n            annotatedBoundary: true,\n            seedPointsCount: 0,\n            style: 0,\n            patternStyle: 1,\n            elevationX: 0,\n            elevationY: 0,\n            elevationZ: 0,\n            extrusionDirectionX: 0,\n            extrusionDirectionY: 0,\n            extrusionDirectionZ: 1,\n            pixelSize: 0,\n            layer: '',\n            colorIndex: 0,\n            lineType: '',\n            lineTypeScale: 1,\n            visible: true,\n            handle: 0,\n            color: 0,\n            inPaperSpace: false,\n            ownerHandle: '',\n            materialObjectHandle: 0,\n            lineweight: -3,\n            extendedData: { customStrings: [], applicationName: '' },\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2: // Pattern name\n                    entity.patternName = curr.value;\n                    break;\n                case 5: // Handle (override to ensure string)\n                    entity.handle = curr.value;\n                    break;\n                case 10: // Elevation point X\n                    entity.elevationX = curr.value;\n                    break;\n                case 20: // Elevation point Y\n                    entity.elevationY = curr.value;\n                    break;\n                case 30: // Elevation point Z\n                    entity.elevationZ = curr.value;\n                    break;\n                case 41: // Pattern scale\n                    entity.patternScale = curr.value;\n                    break;\n                case 47: // Pixel size\n                    entity.pixelSize = curr.value;\n                    break;\n                case 70: // Solid fill flag\n                    entity.solidFill = curr.value === 1;\n                    break;\n                case 71: // Associativity flag\n                    entity.associativity = curr.value === 1;\n                    break;\n                case 73: // Boundary annotation flag\n                    entity.annotatedBoundary = curr.value === 1;\n                    break;\n                case 75: // Hatch style\n                    entity.style = curr.value;\n                    break;\n                case 76: // Hatch pattern type\n                    entity.patternStyle = curr.value;\n                    break;\n                case 91: // Number of boundary paths\n                    entity.boundaryPathsCount = curr.value;\n                    entity.boundaries = [];\n                    break;\n                case 93: // Number of vertices in boundary\n                    const boundaryVerticesCount = curr.value;\n                    const boundary = this.parseHatchVertices(boundaryVerticesCount, scanner);\n                    entity.boundaries.push(boundary);\n                    curr = scanner.lastReadGroup;\n                    break;\n                case 98: // Number of seed points\n                    entity.seedPointsCount = curr.value;\n                    break;\n                case 210: // Extrusion direction X\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220: // Extrusion direction Y\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230: // Extrusion direction Z\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                case 1000: // Extended data application name\n                    entity.extendedData.applicationName = curr.value;\n                    break;\n                case 1001: // Extended data custom strings\n                    entity.extendedData.customStrings.push(curr.value);\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n    parseHatchVertices(n, scanner) {\n        if (!n || n <= 0)\n            throw new Error('n must be greater than 0 vertices');\n        const vertices = [];\n        let vertexIsStarted = false;\n        let vertexIsFinished = false;\n        let curr = scanner.next();\n        for (let i = 0; i < n; i++) {\n            const vertex = { x: 0, y: 0 };\n            while (!scanner.isEOF()) {\n                if (curr.code === 0 || vertexIsFinished)\n                    break;\n                switch (curr.code) {\n                    case 10: // X\n                        if (vertexIsStarted) {\n                            vertexIsFinished = true;\n                            continue;\n                        }\n                        vertex.x = curr.value;\n                        vertexIsStarted = true;\n                        break;\n                    case 20: // Y\n                        vertex.y = curr.value;\n                        break;\n                    case 42: // Bulge\n                        if (curr.value !== 0)\n                            vertex.bulge = curr.value;\n                        break;\n                    default:\n                        if (vertexIsStarted) {\n                            vertices.push(vertex);\n                        }\n                        scanner.rewind();\n                        return vertices;\n                }\n                curr = scanner.next();\n            }\n            vertices.push(vertex);\n            vertexIsStarted = false;\n            vertexIsFinished = false;\n        }\n        scanner.rewind();\n        return vertices;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/hatch.js?");

/***/ }),

/***/ "./esm/entities/insert.js":
/*!********************************!*\
  !*** ./esm/entities/insert.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Insert)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Insert {\n    ForEntityName = 'INSERT';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 2:\n                    entity.name = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 42:\n                    entity.yScale = curr.value;\n                    break;\n                case 43:\n                    entity.zScale = curr.value;\n                    break;\n                case 10:\n                    entity.position = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 70:\n                    entity.columnCount = curr.value;\n                    break;\n                case 71:\n                    entity.rowCount = curr.value;\n                    break;\n                case 44:\n                    entity.columnSpacing = curr.value;\n                    break;\n                case 45:\n                    entity.rowSpacing = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/insert.js?");

/***/ }),

/***/ "./esm/entities/line.js":
/*!******************************!*\
  !*** ./esm/entities/line.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Line {\n    ForEntityName = 'LINE';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of point\n                    entity.vertices.unshift(_ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner));\n                    break;\n                case 11:\n                    entity.vertices.push(_ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner));\n                    break;\n                case 210:\n                    entity.extrusionDirection = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/line.js?");

/***/ }),

/***/ "./esm/entities/lwpolyline.js":
/*!************************************!*\
  !*** ./esm/entities/lwpolyline.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lwpolyline)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Lwpolyline {\n    ForEntityName = 'LWPOLYLINE';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, vertices: [] };\n        let numberOfVertices = 0;\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 38:\n                    entity.elevation = curr.value;\n                    break;\n                case 39:\n                    entity.depth = curr.value;\n                    break;\n                case 70: // 1 = Closed shape, 128 = plinegen?, 0 = default\n                    entity.shape = ((curr.value & 1) === 1);\n                    entity.hasContinuousLinetypePattern = ((curr.value & 128) === 128);\n                    break;\n                case 90:\n                    numberOfVertices = curr.value;\n                    break;\n                case 10: // X coordinate of point\n                    entity.vertices = parseLWPolylineVertices(numberOfVertices, scanner);\n                    break;\n                case 43:\n                    if (curr.value !== 0)\n                        entity.width = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirectionX = curr.value;\n                    break;\n                case 220:\n                    entity.extrusionDirectionY = curr.value;\n                    break;\n                case 230:\n                    entity.extrusionDirectionZ = curr.value;\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\nfunction parseLWPolylineVertices(n, scanner) {\n    if (!n || n <= 0)\n        throw Error('n must be greater than 0 verticies');\n    const vertices = [];\n    let vertexIsStarted = false;\n    let vertexIsFinished = false;\n    let curr = scanner.lastReadGroup;\n    for (let i = 0; i < n; i++) {\n        const vertex = {};\n        while (!scanner.isEOF()) {\n            if (curr.code === 0 || vertexIsFinished)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    if (vertexIsStarted) {\n                        vertexIsFinished = true;\n                        continue;\n                    }\n                    vertex.x = curr.value;\n                    vertexIsStarted = true;\n                    break;\n                case 20: // Y\n                    vertex.y = curr.value;\n                    break;\n                case 30: // Z\n                    vertex.z = curr.value;\n                    break;\n                case 40: // start width\n                    vertex.startWidth = curr.value;\n                    break;\n                case 41: // end width\n                    vertex.endWidth = curr.value;\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        vertex.bulge = curr.value;\n                    break;\n                default:\n                    // if we do not hit known code return vertices.  Code might belong to entity\n                    scanner.rewind();\n                    if (vertexIsStarted) {\n                        vertices.push(vertex);\n                    }\n                    scanner.rewind();\n                    return vertices;\n            }\n            curr = scanner.next();\n        }\n        // See https://groups.google.com/forum/#!topic/comp.cad.autocad/9gn8s5O_w6E\n        vertices.push(vertex);\n        vertexIsStarted = false;\n        vertexIsFinished = false;\n    }\n    scanner.rewind();\n    return vertices;\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/lwpolyline.js?");

/***/ }),

/***/ "./esm/entities/mesh.js":
/*!******************************!*\
  !*** ./esm/entities/mesh.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Mesh {\n    ForEntityName = 'MESH';\n    parseEntity(scanner, curr) {\n        const entity = {\n            type: curr.value,\n            vertices: [],\n            faces: [],\n            edges: [],\n            vertexCount: 0,\n            faceCount: 0,\n            edgeCount: 0,\n            subdivisionLevel: 0,\n            layer: '',\n            colorIndex: 0,\n            lineType: '',\n            lineTypeScale: 1,\n            visible: true,\n            handle: 0,\n            color: 0,\n            inPaperSpace: false,\n            ownerHandle: '',\n            materialObjectHandle: 0,\n            lineweight: -3,\n            extendedData: { customStrings: [], applicationName: '' },\n            extendedDataCodes: [],\n        };\n        curr = scanner.next();\n        while (!scanner.isEOF() && curr.code !== 0) {\n            switch (curr.code) {\n                case 5: // Handle\n                    entity.handle = curr.value;\n                    break;\n                case 71: // Subdivision level\n                    entity.subdivisionLevel = curr.value;\n                    break;\n                case 91: // Vertex count\n                    entity.vertexCount = curr.value;\n                    break;\n                case 92: // Face count\n                    entity.faceCount = curr.value;\n                    break;\n                case 93: // Edge count\n                    entity.edgeCount = curr.value;\n                    // Parse edges\n                    const edge = [];\n                    curr = scanner.next();\n                    while (!scanner.isEOF() && curr.code !== 0 && curr.code !== 94 && curr.code !== 1001) {\n                        if (curr.code === 95) {\n                            edge.push(curr.value);\n                        }\n                        curr = scanner.next();\n                    }\n                    if (edge.length > 0) {\n                        entity.edges.push(edge);\n                    }\n                    scanner.rewind();\n                    break;\n                case 10: // Vertex coordinates\n                    const vertex = { x: curr.value, y: 0, z: 0 };\n                    curr = scanner.next();\n                    if (curr.code !== 20) {\n                        throw new Error(`Expected code 20 for vertex y-coordinate, got ${curr.code}`);\n                    }\n                    vertex.y = curr.value;\n                    curr = scanner.next();\n                    if (curr.code === 30) {\n                        vertex.z = curr.value;\n                        curr = scanner.next();\n                    }\n                    else {\n                        scanner.rewind();\n                    }\n                    entity.vertices.push(vertex);\n                    if (entity.vertexCount === 0) {\n                        entity.vertexCount = entity.vertices.length;\n                    }\n                    break;\n                case 94: // Face indices\n                    const faceSize = curr.value;\n                    if (faceSize > 4) {\n                        curr = scanner.next();\n                        while (!scanner.isEOF() && curr.code !== 0 && curr.code !== 94 && curr.code !== 93 && curr.code !== 1001) {\n                            curr = scanner.next();\n                        }\n                        scanner.rewind();\n                        break;\n                    }\n                    const face = [];\n                    let indicesFound = 0;\n                    while (indicesFound < faceSize && !scanner.isEOF()) {\n                        curr = scanner.next();\n                        if (curr.code === 95) {\n                            face.push(curr.value);\n                            indicesFound++;\n                        }\n                        else if (curr.code === 0 || curr.code === 94 || curr.code === 93 || curr.code === 1001) {\n                            scanner.rewind();\n                            break;\n                        }\n                    }\n                    if (face.length > 0) {\n                        entity.faces.push(face);\n                    }\n                    break;\n                case 1001: // Extended data\n                    entity.extendedData.applicationName = curr.value;\n                    curr = scanner.next();\n                    while (curr.code === 1000 && !scanner.isEOF()) {\n                        entity.extendedData.customStrings.push(curr.value);\n                        curr = scanner.next();\n                    }\n                    scanner.rewind();\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/mesh.js?");

/***/ }),

/***/ "./esm/entities/mleader.js":
/*!*********************************!*\
  !*** ./esm/entities/mleader.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MLeader)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass MLeader {\n    ForEntityName = \"MULTILEADER\";\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        entity.contextData = {\n            leaders: [],\n        };\n        curr = scanner.next();\n        function parseCommonData() {\n            while (!scanner.isEOF()) {\n                switch (curr.code) {\n                    case 0: // END\n                        return;\n                    case 340:\n                        entity.leaderStyleId = curr.value;\n                        break;\n                    case 170:\n                        entity.leaderLineType = curr.value;\n                        break;\n                    case 91:\n                        entity.leaderLineColor = curr.value;\n                        break;\n                    case 341:\n                        entity.leaderLineTypeId = curr.value;\n                        break;\n                    case 171:\n                        entity.leaderLineWeight = curr.value;\n                        break;\n                    case 41:\n                        entity.doglegLength = curr.value;\n                        break;\n                    case 290:\n                        entity.enableLanding = curr.value;\n                        break;\n                    case 291:\n                        entity.enableDogLeg = curr.value;\n                        break;\n                    case 342:\n                        entity.arrowHeadId = curr.value;\n                        break;\n                    case 42:\n                        entity.arrowHeadSize = curr.value;\n                        break;\n                    case 172:\n                        entity.contentType = curr.value;\n                        break;\n                    case 173:\n                        entity.textLeftAttachmentType = curr.value;\n                        break;\n                    case 95:\n                        entity.textLeftAttachmentType = curr.value;\n                        break;\n                    case 174:\n                        entity.textAngleType = curr.value;\n                        break;\n                    case 175:\n                        entity.textAlignmentType = curr.value;\n                        break;\n                    case 343:\n                        entity.textStyleId = curr.value;\n                        break;\n                    case 92:\n                        entity.textColor = curr.value;\n                        break;\n                    case 292:\n                        entity.enableFrameText = curr.value;\n                        break;\n                    case 344:\n                        entity.blockContentId = curr.value;\n                        break;\n                    case 93:\n                        entity.blockContentColor = curr.value;\n                        break;\n                    case 10:\n                        entity.blockContentScale = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 43:\n                        entity.blockContentRotation = curr.value;\n                        break;\n                    case 176:\n                        entity.blockContentConnectionType =\n                            curr.value;\n                        break;\n                    case 293:\n                        entity.enableAnotationScale = curr.value;\n                        break;\n                    case 94:\n                        entity.arrowHeadIndex = curr.value;\n                        break;\n                    case 330:\n                        entity.blockAttributeId = curr.value;\n                        break;\n                    case 177:\n                        entity.blockAttributeIndex = curr.value;\n                        break;\n                    case 44:\n                        entity.blockAttributeWidth = curr.value;\n                        break;\n                    case 302:\n                        entity.blockAttributeTextString = curr.value;\n                        break;\n                    case 294:\n                        entity.textDirectionNegative = curr.value;\n                        break;\n                    case 178:\n                        entity.textAlignInIPE = curr.value;\n                        break;\n                    case 179:\n                        entity.textAttachmentPoint = curr.value;\n                        break;\n                    case 271:\n                        entity.textAttachmentDirectionMText =\n                            curr.value;\n                        break;\n                    case 272:\n                        entity.textAttachmentDirectionBottom =\n                            curr.value;\n                        break;\n                    case 273:\n                        entity.textAttachmentDirectionTop =\n                            curr.value;\n                        break;\n                    case 300: // START CONTEXT_DATA\n                        parseContextData();\n                        break;\n                    default:\n                        _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                        break;\n                }\n                curr = scanner.next();\n            }\n        }\n        function parseContextData() {\n            while (!scanner.isEOF()) {\n                switch (curr.code) {\n                    case 40:\n                        entity.contextData.contentScale = curr.value;\n                        break;\n                    case 10:\n                        entity.contextData.contentBasePosition =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 145:\n                        entity.contextData.landingGap = curr.value;\n                        break;\n                    case 290:\n                        entity.contextData.hasMText = curr.value;\n                        break;\n                    case 304:\n                        entity.contextData.defaultTextContents =\n                            curr.value;\n                        break;\n                    case 11:\n                        entity.contextData.textNormalDirection =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 12:\n                        entity.contextData.textLocation =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 13:\n                        entity.contextData.textDirection =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 140:\n                        entity.contextData.arrowHeadSize = curr.value;\n                        break;\n                    case 41:\n                        entity.contextData.textHeight = curr.value;\n                        break;\n                    case 42:\n                        entity.contextData.textRotation = curr.value;\n                        break;\n                    case 43:\n                        entity.contextData.textWidth = curr.value;\n                        break;\n                    case 44:\n                        entity.contextData.textHeight = curr.value;\n                        break;\n                    case 45:\n                        entity.contextData.textLineSpacingFactor =\n                            curr.value;\n                        break;\n                    case 90:\n                        entity.contextData.textColor = curr.value;\n                        break;\n                    case 170:\n                        entity.contextData.textLineSpacingStyle =\n                            curr.value;\n                        break;\n                    case 171:\n                        entity.contextData.textAttachment =\n                            curr.value;\n                        break;\n                    case 172:\n                        entity.contextData.textFlowDirection =\n                            curr.value;\n                        break;\n                    case 141:\n                        entity.contextData.textBackgroundScaleFactor =\n                            curr.value;\n                        break;\n                    case 92:\n                        entity.contextData.textBackgroundTransparency =\n                            curr.value;\n                        break;\n                    case 291:\n                        entity.contextData.textBackgroundColorOn =\n                            curr.value;\n                        break;\n                    case 292:\n                        entity.contextData.textBackgroundFillOn =\n                            curr.value;\n                        break;\n                    case 293:\n                        entity.contextData.textUseAutoHeight =\n                            curr.value;\n                        break;\n                    case 173:\n                        entity.contextData.textColumnType =\n                            curr.value;\n                        break;\n                    case 142:\n                        entity.contextData.textColumnWidth =\n                            curr.value;\n                        break;\n                    case 143:\n                        entity.contextData.textColumnGutterWidth =\n                            curr.value;\n                        break;\n                    case 144:\n                        entity.contextData.textColumnHeight =\n                            curr.value;\n                        break;\n                    case 295:\n                        entity.contextData.textUseWordBreak =\n                            curr.value;\n                        break;\n                    case 296:\n                        entity.contextData.hasBlock = curr.value;\n                        break;\n                    case 341:\n                        entity.contextData.blockContentId =\n                            curr.value;\n                        break;\n                    case 14:\n                        entity.contextData.blockContentNormalDirection =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 15:\n                        entity.contextData.blockContentPosition =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 16:\n                        entity.contextData.blockContentScale =\n                            curr.value;\n                        break;\n                    case 46:\n                        entity.contextData.blockContentRotation =\n                            curr.value;\n                        break;\n                    case 93:\n                        entity.contextData.blockContentColor =\n                            curr.value;\n                        break;\n                    case 47:\n                        entity.contextData.blockTransformationMatrix = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parseMatrix(scanner, 47);\n                        break;\n                    case 110:\n                        entity.contextData.planeOriginPoint =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 111:\n                        entity.contextData.planeXAxisDirection =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 112:\n                        entity.contextData.planeYAxisDirection =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 297:\n                        entity.contextData.planeNormalReversed =\n                            curr.value;\n                        break;\n                    case 301: // END CONTEXT_DATA\n                        return;\n                    case 302: // START LEADER\n                        parseLeaderData();\n                        break;\n                    default:\n                        break;\n                }\n                curr = scanner.next();\n            }\n        }\n        function parseLeaderData() {\n            const leader = {\n                leaderLines: [],\n            };\n            entity.contextData.leaders.push(leader);\n            while (!scanner.isEOF()) {\n                switch (curr.code) {\n                    case 290:\n                        leader.hasSetLastLeaderLinePoint =\n                            curr.value;\n                        break;\n                    case 291:\n                        leader.hasSetDoglegVector = curr.value;\n                        break;\n                    case 10:\n                        leader.lastLeaderLinePoint =\n                            _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 11:\n                        leader.doglegVector = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                        break;\n                    case 90:\n                        leader.leaderBranchIndex = curr.value;\n                        break;\n                    case 40:\n                        leader.doglegLength = curr.value;\n                        break;\n                    case 303: // END LEADER\n                        return;\n                    case 304: // START LEADER_LINE\n                        parseLeaderLineData();\n                        break;\n                    default:\n                        break;\n                }\n                curr = scanner.next();\n            }\n        }\n        function parseLeaderLineData() {\n            const leader = entity.contextData.leaders[entity.contextData.leaders.length - 1];\n            const line = {\n                vertices: [[]],\n            };\n            leader.leaderLines.push(line);\n            while (!scanner.isEOF()) {\n                switch (curr.code) {\n                    case 10:\n                        line.vertices[0].push(_ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner));\n                        break;\n                    case 305: // END LEADER_LINE\n                        return;\n                    default:\n                        break;\n                }\n                curr = scanner.next();\n            }\n        }\n        parseCommonData();\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/mleader.js?");

/***/ }),

/***/ "./esm/entities/mtext.js":
/*!*******************************!*\
  !*** ./esm/entities/mtext.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mtext)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Mtext {\n    ForEntityName = 'MTEXT';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 3:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 1:\n                    entity.text ? entity.text += curr.value : entity.text = curr.value;\n                    break;\n                case 10:\n                    entity.position = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.directionVector = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40:\n                    //Note: this is the text height\n                    entity.height = curr.value;\n                    break;\n                case 41:\n                    entity.width = curr.value;\n                    break;\n                case 50:\n                    entity.rotation = curr.value;\n                    break;\n                case 71:\n                    entity.attachmentPoint = curr.value;\n                    break;\n                case 72:\n                    entity.drawingDirection = curr.value;\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/mtext.js?");

/***/ }),

/***/ "./esm/entities/point.js":
/*!*******************************!*\
  !*** ./esm/entities/point.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Point)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Point {\n    ForEntityName = 'POINT';\n    parseEntity(scanner, curr) {\n        const type = curr.value;\n        const entity = { type };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.position = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 39:\n                    entity.thickness = curr.value;\n                    break;\n                case 210:\n                    entity.extrusionDirection = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 100:\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/point.js?");

/***/ }),

/***/ "./esm/entities/polyline.js":
/*!**********************************!*\
  !*** ./esm/entities/polyline.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Polyline)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n/* harmony import */ var _vertex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vertex.js */ \"./esm/entities/vertex.js\");\n\n\nclass Polyline {\n    ForEntityName = 'POLYLINE';\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value, vertices: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // always 0\n                    break;\n                case 20: // always 0\n                    break;\n                case 30: // elevation\n                    break;\n                case 39: // thickness\n                    entity.thickness = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 70:\n                    entity.shape = (curr.value & 1) !== 0;\n                    entity.includesCurveFitVertices = (curr.value & 2) !== 0;\n                    entity.includesSplineFitVertices = (curr.value & 4) !== 0;\n                    entity.is3dPolyline = (curr.value & 8) !== 0;\n                    entity.is3dPolygonMesh = (curr.value & 16) !== 0;\n                    entity.is3dPolygonMeshClosed = (curr.value & 32) !== 0; // 32 = The polygon mesh is closed in the N direction\n                    entity.isPolyfaceMesh = (curr.value & 64) !== 0;\n                    entity.hasContinuousLinetypePattern = (curr.value & 128) !== 0;\n                    break;\n                case 71: // Polygon mesh M vertex count\n                    break;\n                case 72: // Polygon mesh N vertex count\n                    break;\n                case 73: // Smooth surface M density\n                    break;\n                case 74: // Smooth surface N density\n                    break;\n                case 75: // Curves and smooth surface type\n                    break;\n                case 210:\n                    entity.extrusionDirection = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        entity.vertices = parsePolylineVertices(scanner, curr);\n        return entity;\n    }\n}\nfunction parsePolylineVertices(scanner, curr) {\n    const vertexParser = new _vertex_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    const vertices = [];\n    while (!scanner.isEOF()) {\n        if (curr.code === 0) {\n            if (curr.value === 'VERTEX') {\n                vertices.push(vertexParser.parseEntity(scanner, curr));\n                curr = scanner.lastReadGroup;\n            }\n            else if (curr.value === 'SEQEND') {\n                parseSeqEnd(scanner, curr);\n                break;\n            }\n        }\n    }\n    return vertices;\n}\nfunction parseSeqEnd(scanner, curr) {\n    const entity = { type: curr.value };\n    curr = scanner.next();\n    while (!scanner.isEOF()) {\n        if (curr.code == 0)\n            break;\n        _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n        curr = scanner.next();\n    }\n    return entity;\n}\n;\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/polyline.js?");

/***/ }),

/***/ "./esm/entities/solid.js":
/*!*******************************!*\
  !*** ./esm/entities/solid.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Solid)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Solid {\n    ForEntityName = 'SOLID';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value, points: [] };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    entity.points[0] = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11:\n                    entity.points[1] = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 12:\n                    entity.points[2] = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.points[3] = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 210:\n                    entity.extrusionDirection = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/solid.js?");

/***/ }),

/***/ "./esm/entities/spline.js":
/*!********************************!*\
  !*** ./esm/entities/spline.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Spline)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Spline {\n    ForEntityName = 'SPLINE';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10:\n                    if (!entity.controlPoints)\n                        entity.controlPoints = [];\n                    entity.controlPoints.push(_ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner));\n                    break;\n                case 11:\n                    if (!entity.fitPoints)\n                        entity.fitPoints = [];\n                    entity.fitPoints.push(_ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner));\n                    break;\n                case 12:\n                    entity.startTangent = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 13:\n                    entity.endTangent = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40:\n                    if (!entity.knotValues)\n                        entity.knotValues = [];\n                    entity.knotValues.push(curr.value);\n                    break;\n                case 70:\n                    if ((curr.value & 1) != 0)\n                        entity.closed = true;\n                    if ((curr.value & 2) != 0)\n                        entity.periodic = true;\n                    if ((curr.value & 4) != 0)\n                        entity.rational = true;\n                    if ((curr.value & 8) != 0)\n                        entity.planar = true;\n                    if ((curr.value & 16) != 0) {\n                        entity.planar = true;\n                        entity.linear = true;\n                    }\n                    break;\n                case 71:\n                    entity.degreeOfSplineCurve = curr.value;\n                    break;\n                case 72:\n                    entity.numberOfKnots = curr.value;\n                    break;\n                case 73:\n                    entity.numberOfControlPoints = curr.value;\n                    break;\n                case 74:\n                    entity.numberOfFitPoints = curr.value;\n                    break;\n                case 210:\n                    entity.normalVector = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/spline.js?");

/***/ }),

/***/ "./esm/entities/text.js":
/*!******************************!*\
  !*** ./esm/entities/text.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Text {\n    ForEntityName = 'TEXT';\n    parseEntity(scanner, curr) {\n        const entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X coordinate of 'first alignment point'\n                    entity.startPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 11: // X coordinate of 'second alignment point'\n                    entity.endPoint = _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.parsePoint(scanner);\n                    break;\n                case 40: // Text height\n                    entity.textHeight = curr.value;\n                    break;\n                case 41:\n                    entity.xScale = curr.value;\n                    break;\n                case 50: // Rotation in degrees\n                    entity.rotation = curr.value;\n                    break;\n                case 1: // Text\n                    entity.text = curr.value;\n                    break;\n                // NOTE: 72 and 73 are meaningless without 11 (second alignment point)\n                case 72: // Horizontal alignment\n                    entity.halign = curr.value;\n                    break;\n                case 73: // Vertical alignment\n                    entity.valign = curr.value;\n                    break;\n                default: // check common entity attributes\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/text.js?");

/***/ }),

/***/ "./esm/entities/vertex.js":
/*!********************************!*\
  !*** ./esm/entities/vertex.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vertex)\n/* harmony export */ });\n/* harmony import */ var _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParseHelpers.js */ \"./esm/ParseHelpers.js\");\n\nclass Vertex {\n    ForEntityName = 'VERTEX';\n    parseEntity(scanner, curr) {\n        var entity = { type: curr.value };\n        curr = scanner.next();\n        while (!scanner.isEOF()) {\n            if (curr.code === 0)\n                break;\n            switch (curr.code) {\n                case 10: // X\n                    entity.x = curr.value;\n                    break;\n                case 20: // Y\n                    entity.y = curr.value;\n                    break;\n                case 30: // Z\n                    entity.z = curr.value;\n                    break;\n                case 40: // start width\n                    break;\n                case 41: // end width\n                    break;\n                case 42: // bulge\n                    if (curr.value != 0)\n                        entity.bulge = curr.value;\n                    break;\n                case 70: // flags\n                    entity.curveFittingVertex = (curr.value & 1) !== 0;\n                    entity.curveFitTangent = (curr.value & 2) !== 0;\n                    entity.splineVertex = (curr.value & 8) !== 0;\n                    entity.splineControlPoint = (curr.value & 16) !== 0;\n                    entity.threeDPolylineVertex = (curr.value & 32) !== 0;\n                    entity.threeDPolylineMesh = (curr.value & 64) !== 0;\n                    entity.polyfaceMeshVertex = (curr.value & 128) !== 0;\n                    break;\n                case 50: // curve fit tangent direction\n                    break;\n                case 71: // polyface mesh vertex index\n                    entity.faceA = curr.value;\n                    break;\n                case 72: // polyface mesh vertex index\n                    entity.faceB = curr.value;\n                    break;\n                case 73: // polyface mesh vertex index\n                    entity.faceC = curr.value;\n                    break;\n                case 74: // polyface mesh vertex index\n                    entity.faceD = curr.value;\n                    break;\n                default:\n                    _ParseHelpers_js__WEBPACK_IMPORTED_MODULE_0__.checkCommonEntityProperties(entity, curr, scanner);\n                    break;\n            }\n            curr = scanner.next();\n        }\n        return entity;\n    }\n}\n\n\n//# sourceURL=webpack://DxfParser/./esm/entities/vertex.js?");

/***/ }),

/***/ "./esm/index.js":
/*!**********************!*\
  !*** ./esm/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DxfParser: () => (/* reexport safe */ _DxfParser_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"default\": () => (/* reexport safe */ _DxfParser_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _DxfParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DxfParser.js */ \"./esm/DxfParser.js\");\n\n\n\n//# sourceURL=webpack://DxfParser/./esm/index.js?");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else // removed by dead control flow\n{}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n\n\n//# sourceURL=webpack://DxfParser/./node_modules/loglevel/lib/loglevel.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./esm/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__.DxfParser;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});